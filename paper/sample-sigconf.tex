\documentclass[sigconf]{acmart}

\usepackage{booktabs} % For formal tables
%\usepackage{indentfirst}
%\usepackage{amsthm}
%\usepackage{amsmath}
%\usepackage{amssymb}
\usepackage{paralist}
%\usepackage{graphicx}
%\usepackage{verbatim}
\usepackage{algorithm}{}
\usepackage{algorithmic}
\usepackage{clrscode3e}
%\newtheorem{mydef}{Definition}
%\newtheorem{theorem}{Theorem}
%\usepackage{amsthm}
\usepackage{subcaption}
\renewcommand{\algorithmicrequire}{ \textbf{Input:}}  
\renewcommand{\algorithmicensure}{ \textbf{Output:}}



% Copyright
%\setcopyright{none}
%\setcopyright{acmcopyright}
%\setcopyright{acmlicensed}
\setcopyright{rightsretained}

%\setcopyright{usgov}
%\setcopyright{usgovmixed}
%\setcopyright{cagov}
%\setcopyright{cagovmixed}


% DOI
\acmDOI{10.475/123_4}

% acmISBN
\acmISBN{123-4567-24-567/08/06}

%Conference
%\acmConference[WOODSTOCK'97]{ACM Woodstock conference}{July 1997}{ElPaso, Texas USA}
%\acmYear{1997}
%\copyrightyear{2016}


\acmArticle{4}
\acmPrice{15.00}

% These commands are optional
%\acmBooktitle{Transactions of the ACM Woodstock conference}
%\editor{Rongkun Yan}
%\editor{Jian Guo}
%\editor{Xiaoran Zhu}
%\editor{Xin Li}
%\editor{Jizheng Ding}


\begin{document}
%\setlength{\baselineskip}{20pt}
\title{Timing Modeling and Analysis for AUTOSAR OS Schedule Tables}
\titlenote{Produces the permission block, and
  copyright information}
%\subtitle{Extended Abstract}
%\subtitlenote{The full version of the author's guide is available as
  %\texttt{acmart.pdf} document}


%\author{Rongkun Yan}
%\affiliation{%
%  \institution{Soft/Hardware Co-design Engineering Research Center, East China Normal University}
%}
%\email{51164500085@stu.ecnu.edu.cn}

%\author{Jian Guo}
%\affiliation{%
%  \institution{Soft/Hardware Co-design Engineering Research Center, East China Normal University}
%}
%\email{jguo@sei.ecnu.edu.cn}

%\author{Xiaoran Zhu}
%\affiliation{%
%  \institution{National Trusted Embedded Software Engineering Technology Research Center, East China Normal University}
%}

%\author{Xin Li}
%\affiliation{%
%  \institution{Shanghai Key Laboratory of Trustworthy Computing, East China Normal University}
%}

%\author{Jizheng Ding}
%\affiliation{%
%  \institution{Soft/Hardware Co-design Engineering Research Center, East China Normal University}
%}



% The default list of authors is too long for headers.
%\renewcommand{\shortauthors}{B. Trovato et al.}


\begin{abstract}
Schedule table mechanism is an important characteristic in AUTOSAR OS during addressing its real-time property and flexibility. Schedule table provides an encapsulation of a statical configuration with one or more actions (i.e., events set or tasks activation). It is challenging to manually analyze schedulability of tasks in schedule tables. In this paper, we take into consideration the AUTOSAR OS scheduling with preemptive periodic schedule tables in uniprocessor. A schedule table is formally modelled by a transition system.
An algorithm based on the models is presented to analyze schedulability by checking all of the possible offsets between schedule tables.
Furthermore, checking schedulability tool is implemented. Testbenches of schedule tables are executed in our tool and an industrial AUTOSAR OS on microcontroller respectively. The result demonstrates our method is effective.
\end{abstract}

%
% The code below should be generated by the tool at
% http://dl.acm.org/ccs.cfm
% Please copy and paste the code instead of the example below.
%


%\ccsdesc[500]{Computer systems organization~Embedded systems}\ccsdesc[300]{Computer systems organization~Redundancy}\ccsdesc{Computer systems organization~Robotics}\ccsdesc[100]{Networks~Network reliability}


%\keywords{ACM proceedings, \LaTeX, text tagging}


\maketitle

\section{Introduction}
Formal methods have been widely and successfully applied to functional properties verification. Unfortunately, it is difficult to verify some non-functional characteristics, which are the key to maintain validity in highly safety-critical real-time systems. Formal analysis on schedulability of task models is researched. Liu et. al \cite{DBLP:journals/jacm/LiuL73} first build a task model for periodic tasks with a period and execution time, and discuss two scheduling algorithms over the model. Stigge et al. \cite{DBLP:conf/rtas/StiggeEGY11} describe a task with a Diagraph Real-Time (DRT) task model, and study the feasibility problem on preemptive periodic tasks in a uniprocessor. For analyzing the temporal validity of real-time data objects, Wang et al. \cite{DBLP:journals/computing/WangLHSM13} give transaction model with three parameters, a fixed priority, its worst-case execution time (WCET) and a relative deadline. The temporal validity of real-time data object is  analyzed by periodic update transactions. S.Baruah \cite{DBLP:conf/rtss/Baruah16} analyze schedulability in a general 3-parameter sporadic task model \cite{DBLP:journals/csur/BurnsD17} for mixed-criticality concurrent real-time tasks. Moreover, S.Baruah et al. \cite{DBLP:conf/rtns/2017} propose a scheduling model for periodic preemptive tasks inspired by control theory. Despite the rapid advancements in real-time scheduling theory, industry is willing to employ the very simple cyclic executive approach \cite{DBLP:journals/rts/BakerS89} for corrective scheduling to meet stringent certification requirement,. C.Deutschbein et al. \cite{DBLP:conf/setta/2017} present the problem of constructing cyclic executive upon multiprocessors.

AUTOSAR (AUTomotive Open System ARchitecture) \cite{autosar} is an open and standardized layered software architecture and interfaces. The integration of software modules from different vendors forms the complete architecture. As a consequence, more and more automotive companies tend to take AUTOSAR as their primary standard for developing their base software project, such as operating system. Researchers working on AUTOSAR OS are rich in progressive and proactive. There have been many studies on analyzing AUTOSAR OS specification \cite{DBLP:conf/isorc/AnssiTKGT11}. 
%Peng et al. adopt timed CSP method to model OS and the engine management system (EMS), some safety properties based on CSP models are verified through process analysis toolkit in \cite{DBLP:conf/tase/PengHSG13}. Huang et al. \cite{DBLP:conf/icfem/HuangFHQH13} apply formal semantics to describing tasks in AUTOSAR OS with time protection mechanism. The model predicts whether a task would violate its time constraint, and is implemented in Mathematica tool with a case study. Zhu et al. \cite{DBLP:conf/tase/ZhuLSWZ13} focus on the timing properties of AUTOSAR OS and propose an automatic verification framework based on rewriting logic to analyze the timing behaviors. Therefore, many researches of AUTOSAR OS focus on its specification, implementation and verification. 
For schedulability of the AUTOSAR OS, both Zhao et al. \cite{DBLP:journals/jsa/ZhaoGZ17} and Hatvani et al. \cite{DBLP:conf/etfa/HatvaniB15} adopt preemptive threshold to improve the schedulability. Tasks are set with a higher priority and reduced execution time by the stack usage. In order to assist developers to assign the priorities of tasks, Yoon et al. \cite{DBLP:conf/racs/YoonR14} present a real-time task chain model, which helps to obtain a near-optimal priority assignment from the model. They concentrate on the scheduling of tasks, but few researches deal with schedule tables. Wang et al. propose a method for generating schedule tables containing periodic tasks with dependence in \cite{DBLP:conf/dasip/WangCM16} for the multi-core architectures. However the method does not give the correctness proof of generating schedule tables.

Among those aforementioned researchers, most of them analyze schedulability by modeling tasks, few attentions were given to schedule table mechanism \cite{autosar}, which is an important mechanism in AUTOSAR OS. For automobile being a high safety-critical real time system, a practical approach \cite{DBLP:journals/rts/BakerS89} applies to schedule tables in order to satisfy all tasks deadline. Inspired by the method, we present a formal method to build deterministic schedule tables. The correctness of these deterministic schedule tables is proved, which means to verify every task in schedule tables meets its deadline.

A formal model is constructed for each schedule table. A set of schedule tables are composed by concurrent of all models. Tasks in schedule tables are static analyzed to prove that whether tasks run in the worst case response time. We propose an algorithm to travel all of the possible offsets between schedule tables so that each situation can exactly complete task execution. A time interval between a task releasing and its deadline is checked to confirm whether enough execution time for itself and other higher priority tasks. Because all schedule tables in this method are periodic, analysis of infinite running of tasks is transformed to finite running of tasks by introducing hyperperiod of schedule tables. In addition, after analyzing the schedulability of a set of schedule tables by our approach, we run testbenches of schedule tables on an implemented AUTOSAR OS based on TC1782 32-Bit Single-Chip Micro-controller. The result shows the consistency between them.


The rest of this paper is organized as follows. Section 2 introduces some concepts of AUTOSAR and schedulability analysis. Section 3 discusses the constraints of AUTOSAR OS in this paper and describes our formal models of schedule tables. Section 4 presents some definitions and notations of our algorithm. In Section 5, we propose a method by integrating concepts in section 4. Then, we compare the result of our method with the execution on hardware in Section 6. Finally, in Section 7, we give the conclusion and future work.
\section{Background}
For a better understanding of our work, we give a brief overview of AUTOSAR operating system and methods of schedulability analysis.
\subsection{AUTOSAR Operate System}

This part is given as prerequisites of this paper. We will state some concepts of AUTOSAR which will be used later. Those concepts are referred to OSEK/VDX operating system specification \cite{osek} and specification of AUTOSAR operating system \cite{autosar}.
\subsubsection{Tasks and Scheduling Policy}

AUTOSAR considers a task as the minimum unit to schedule. Even a simple application also needs to map to a task. Each task has to accomplish a specific function. The implementation of a task consists of a block of sequential code. AUTOSAR provides two types of tasks: extended and basic tasks.

Each basic task has three states: $running$, $suspended$ and $ready$. A task in the $running$ state is executed by processor. A suspended task can be put into ready queue by a system service which will transfer the task into $ready$ state. A task in $ready$ state means the task is waiting for allocation of the processor. At most one task can be in $running$ state at the same time. Once a basic task in $running$ state is preempted by a task with a higher priority, it will be transferred into $ready$ state. A running task is transferred into $suspended$ state by a system service to terminate a task. An extended task has a strong resemblance to a basic task with except that 1) the former one could wait for a system event in an extra state named $waiting$, 2) the basic task is allowed to be activated once or multiple times while an extended task can only be activated once. 
%a major difference is the former has an extra state named \emph{waiting} to describe an extend task is waiting for a system event.  only when an extend task in $running$ state runs into a system service, the task can transform into $waiting$ state, then the processor will be reassigned to another task, the extended task in $waiting$ state could be executed continuously until an event occur. Except that, another difference between those two types is basic tasks can be activated once or multiple times, but for each extended task, ready queue only could contain one instance of it. 

AUTOSAR uses the highest priority first and first come first served as its scheduling policy. AUTOSAR reserves a FIFO queue for each priority. When a task is activated, it will be put into the corresponding queue. Then scheduler will detect those queues in order of the highest priority and choose the task with the highest priority to execute. If more than one tasks in ready queue have the highest priority, the scheduler will choose the first one has been put into the ready queue. For the high efficiency of the system, the priorities are distributed to tasks statically.

%\subsubsection{Scheduling Policy}AUTOSAR use highest priority first policy as the first scheduling policy, and first in first out (FIFO) as second scheduling policy. AUTOSAR reserves a FIFO queue for each priority, whenever a task is activated, system puts it into the corresponding queue, and scheduler will detect from the queue with priority high to low, and choose the task with the highest priority transform into $running$ state (in full preemptive scheduling), and when more than one tasks have the highest priority in a queue, the scheduler will choose the task which activate earliest, i.e., the task at head of the queue. For the high efficiency of the system, tasks in AUTOSAR cannot be modified dynamically (ignore priority ceiling protocol), developers need to distribute a priority to each task offline. The schedule attribute defines the preemptible of a task, AUTOSAR provides three cases of schedule attributes: \emph{full preemptive schedulling}, \emph{non preemptive schedulling} and \emph{mixed preemptive schedulling}. A full preemptive task which in $running$ state may be preempted before the last instruction is completed by an interrupting of a task with higher priority or an interrupt service routine (ISR). The state of a task has just been preempted will turn into $ready$ state and scheduler will put it back into the head of the corresponding queue. Non-preemptive scheduling means a non-preemptive task in $running$ state only release processor when the task has been successful terminate, or after extended task waits for system events and transform into $waiting$ state, besides, even a task with higher priority in $ready$ state cannot affect the execution of it. In the \emph{mixed preemptive schedulling} case, full preemptive tasks and non-preemptable tasks can coexist in an operating system, and if a full preemptive task was executing, the system will perform preemptive scheduling, instead, if the processor was working on a non-preemptive task, the system will perform non-preemptive scheduling.

%\subsubsection{Counters and Alarms}After giving the definition of counters, we introduce the concept of alarms. AUTOSAR satisfy the request of processing recurring events by defining alarms. Each alarm links to a counter and a set of actions, those actions could be activating tasks, setting events or entry callback routines. While the AUTOSAR operate system is running, users could set a counter value of the alarm by calling the API $SetRelAlarm$ (relative to the counter) or $SetAbsAlarm$ (absolute value of counter), whenever the corresponding counter records a tick elapses, the returned value of the counter has to compare with counter value of this alarm, and if they are equal, those actions defined in advance will be executed. %single shot or cyclic alarm
\subsubsection{Schedule Table Mechanism}

The schedule table mechanism is a new concept introduced in AUTOSAR which could statically define the pattern of tasks activation. Each schedule table encapsulates a predefined set of expiry points. An expiry point contains one or more actions which can be either activating a task or setting an event. Each expiry point has a unique offset in ticks from the start of the schedule table. In addition, a schedule table has a specific duration which defines the modulus of the schedule table. The process of schedule tables can be manipulated as users call system services at any time.

%At runtime, a schedule table is driven by a counter. One tick on the counter corresponds to one tick on schedule table. Since a schedule table start, if the increment of the counter equals to an offset of an expiry point, the actions of this expiry point will be executed.  %We illustrate these three states and the transitions between them in Figure \ref{figure_state_st} which we get from \cite{autosar}.

%\begin{figure}[t]
%\centering
%\includegraphics[scale=.39]{graphics/Figure_state_st.eps}
%\caption{Three states of schedule table and the transitions between them.}
%\label{figure_state_st}
%\end{figure}

%A schedule table is initialized as \emph{SCHEDULETABLE\_STOPPED} state. Users can activate the schedule table by system services \emph{StartScheduleTableAbs} or \emph{StartScheduleTableRel}. When corresponding counter reaches the preset value, the schedule table will be transferred into \emph{SCHEDULETABLE\_RUNNING} state. In this state, expiry points of the schedule table could be iterated in order until schedule table ends. After that, the state will be transferred into \emph{SCHEDULETABLE\_STOPPED}. When a user calls the system service \emph{NextScheduleTable}, the schedule table will be transferred into \emph{SCHEDULETABLE\_NEXT} state from \emph{SCHEDULETABLE\_STOPPED} state, which means the schedule table is waiting for the current schedule table to end. The transition into the \emph{SCHEDULETABLE\_STOPPED} state is triggered by system service \emph{StopScheduleTable}.

%Users can also turn the state of schedule tables into \emph{SCHEDULETABLE\_STOPPED} by system service \emph{StopScheduleTable} at any time.

AUTOSAR offers two types of behavior of schedule tables: single-shot and repeating. On one hand, if a schedule table is configured as single-shot, it will stop after the final expiry point is processed. On the other hand, for a repeating schedule table, after the final expiry point has been processed, it loops back to the first expiry point. Note that for tasks activated by a repeating schedule table, they can be regarded as periodic tasks and their period equals to the duration of the repeating schedule table.

We give a simple example in Figure \ref{figure_st1} to illustrate the construction of schedule table. This schedule table is denoted by $st_1$ with the duration of 17 ticks. $st_1$ contains three expiry points $ep_1$, $ep_2$ and $ep_3$, where the initial expiry point $ep_1$ locates at 4 ticks from the start of $st_1$ with the action of activating task $t_1$, $ep_2$ defines 8 ticks as its offset and could activate task $t_2$, $ep_3$ defines 11 ticks as its offset and activates task $t_3$. The delays between two adjacent expiry points are shown as 4 ticks (from EP1 to EP2) and 3 ticks (from EP2 to EP3).
\begin{figure}[t]
  \centering
  \includegraphics[scale=.32]{graphics/figure_st1.eps}
  \caption{An example repeating scheduel table cotaining three expiry points, and $t_1,t_2,t_3$ is three tasks.}
  \label{figure_st1}
\end{figure}
%As we know, the absoult time of initial expiry of a schedule table is under user control, but if the schedule table is repeating, then, the time of initial expiry point been reached cannot be the same, this problem is cause by the duration of schedule not necessary be equal to the counter modulus.
\subsection{Schedulability Analysis}
The researches about schedulability analysis focus on the problem whether real-time tasks could satisfy its time property. We declare the meaning of schedulability: schedulability declare whether a set of schedule tables is schedulable. Schedulable means all tasks activated by schedule tables could take to execute before its deadline, otherwise, this set of schedule tables is non-schedulable.

In order to figure out the schedulability of real-time systems, several formal models have been presented to abstract the behaviors of tasks. Generally, a model abstracts a task as a tuple $(T_i,D_i,C_i,L_i)$, which represent its period, deadline, worst case execution time and priority level respectively \cite{DBLP:journals/csur/BurnsD17}. 
%An unbounded sequence of tasks may be obtained by this model, which makes schedulability analysis complicated, especially when tasks are full preempted. i.e., the tasks with higher priority may interfere the execution of tasks with lower priority.

We can categorize those schedulability analysis methods by the existing scheduling algorithm. One of the most common algorithm is the earliest deadline first algorithm (EDF). EDF is considered as an optimized algorithm on preemptive uniprocessors to analyze a set of independent tasks characterized by activate time, deadline and worst case execution time. For such a dynamic priority scheduling algorithm, the schedulability analysis methods which determines whether a system is EDF schedulable is co-NP in the strong sense \cite{Goossens:1999:LWC:553897}.

Since our work focuses on the single processor platform with static priority scheduling, we now pay attention the schedulability analysis method based on the response time analysis (RTA) \cite{DBLP:journals/iee/AudsleyBRTW93}. Response time analysis is suited for fixed priority tasks system. This method calculate the worst case response time, then verify whether the worst case response time of a task is in its deadline. 

\section{Formal models of schedule tables} 
For AUTOSAR operating system, there are two main factors that make the schedulability analysis intractable: 1) generally, there are several schedule tables run concurrently, 2) users can manipulate the proceeding of schedule tables by calling system services, i.e., schedule tables may stop or start running at any time, which is totally unpredictable. Those factors bring more complication to schedulability analysis. 

The problem of schedulability analysis raises two questions: 1) how to define a proper formal model to describe the behavior of schedule tables, 2) how to propose an algorithm to analyse the schedulability of schedule tables by the formal model. In this section, we state our solution to the first problem. 

\subsection{Constraints of AUTOSAR OS}
On account of the widespread use of embedded automotive systems, different embedded applications may require various characteristics of operating systems as well as hardware environments are also likely to be different. Those factors demand different features of the AUTOSAR operating system. For those features, our work focus on several characteristics among them: 
\begin{compactenum}
  \item Tasks are allowed to share the same priority level and lower number for higher priority.
  \item We take no account of extended tasks and events.
  \item All tasks are full preemptible.
  \item The scheduling policy is the highest priority first. When there are more than one tasks have the same priority. The scheduler will choose the first one has been put into the ready queue.
  \item A basic task can be activated infinitely many times. 
\end{compactenum}

For convenience, if a task is assigned to more than one expiry points, we regard them as different tasks. In additional, we assume all schedule tables are repeating. In fact, a repeating schedule table could be transferred to a single-shot schedule table by converting the final delay into infinitely great.

\subsection{Formal Models}
We use a directed digraph to describe the behavior of a schedule table and named it Digraph Schedule Table model (DST). Each DST is a tuple $(Node,Tasks,Act,\rightarrow,Delay)$, where
\begin{compactitem}
  \item $Node$ is a finite set of expiry points.
  \item $Tasks$ is a finite set of tasks. We use a tuple $(e,d,l)$ to represent a task. Assuming $t_k\in Tasks$, then $e(t_k),d(t_k),l(t_k)$ denote the execution time, deadline and priority level of task $t_k$ respectively.% In the beginning, release time of all tasks set to 0, and could be modified during verify procedure.
  \item $Act$ : $Node \rightarrow 2^{Tasks}$ is a function. $Act$ relates a set $Act(ep)\in 2^{Tasks}$ of actions to an expiry point $ep$.
  \item $\rightarrow\ \subseteq Node\times Node$ is a transition relation to describe the execution sequence of expiry points. 
  \item $Delay$ : $Node \rightarrow ticks$ is a function to describe the delay after processing an expiry point. $Delay$ of the last expiry point of a schedule table equals to the final delay plus the initial offset.
\end{compactitem}

Note that we conceal the initial offset in DST. Because in the processing of a repeating schedule table, except the first loop, the initial offset always can be considered as a part of the delay of the last expiry point.
%and our method traverses all relative offset between schedule tables. Section \ref{section_combination} will discuss that in more detail.

With regard to the definition of $Delay$, the duration of a schedule table can be obtained by 
\[\delta(DST)=\sum\limits_{ep_i\in Node}Delay(ep_i).\]

During the execution of a schedule table, expiry points will expire circularly. We record each time of expiring as an instance of expiry point. An instance of expiry point is specified by an expiry point and the time it expires. We use a pair $(ep_i,r_i)$ to represent an instance, where $r_i$ is the time that the expiry point expires. 
Naturally to point out that an execution of a DST corresponds to an infinite sequence of instances of expiry points. 
We use a path $\rho=[(ep_1,r_1),(ep_2,r_2),\dots,(ep_k,r_k)]$ to denote a fragment of an execution. When an expiry point expire, corresponding tasks will be activated then. For each time a task is activated, we record that as an instance of task. We use a 4-tuple $(e_i,d_i,l_i,r_i)$ to denote an instance of a task with execute time $e_i$, deadline $d_i$, priority $l_i$ and activate time $r_i$. Durning a path, expire times of instances of expiry points are constrained by the delay of corresponding expiry points, i.e., 
\[r_{i+1}=r_i+Delay(ep_i).\]

Similar to the calculation of duration, we get the length of a path by accumulating delays of expiry points. For a path $\rho=[(ep_1,r_1),(ep_2,r_2),\dots,(ep_k,r_k)]$, the length $\iota(\rho)$ is calculating by: 
\[\iota(\rho)=\sum_{i=1}^{k-1} Delay(\rho_i),\]
where we use $\rho_i$ to represent the $i$th instance of expiry point in the path $\rho$, $ep(\rho_i)$ to represent this expiry point and $r(\rho_i)$ to represent the expire time. For a path which only contains a single expiry point, we make the length of it as 0. %As an example, for a path $\rho=[(ep_4,0),(ep_5,3)(ep_4,14),(ep_5,17)]$, $\rho_3$ represents $ep_4$.


\subsection{Example Model}\label{section_dst_1}
We model the scheduel table which mentioned above in Figure \ref{figure_dst1} and give the tuple of $dst_1$ as follow.
\begin{figure}
  \centering
  \includegraphics[scale=.45]{graphics/figure_dst1.eps}
  \caption{An example of DST for $st_1$, where $t_1=<2,4,2>,\ t_2=<2,3,1>\ t_3=<2,9,6>$.}
  \label{figure_dst1}
\end{figure}

$dst_1=\{Node_1,Tasks_1,Act_1,\rightarrow_1,Delay_1\}$, where 
\begin{compactitem}
\item $Node_1=\{ep_1,\ ep_2,\ ep_3\}$ which cotains all expiry points in $dst_1$.
\item $Tasks_1=\{t_1,\ t_2,\ t_3\}$ which cotains all tasks in $dst_1$.
\item $Act_1$ refers to actions of an expiry point:$Act_1(ep_1)=t_1,\ Act_1(ep_2)=t_2,\ Act_1(ep_3)=t_3$.
\item $\rightarrow_1=\{(ep_1,ep_2),(ep_2,ep_3),(ep_3,ep_1)\}$ which shows the execution sequence of expiry points.
\item $Delay_1:$ the $Delay$ of expiry points is defined by $Delay_1(ep_1)=4,\ Delay_1(ep_2)=3,\ Delay_1(ep_3)=10$.
\end{compactitem}

We assume there is a path $\rho$ over $dst_1$ which $\rho_1=ep_1$ and $r_1=0$. The expire time of second instance of expiry point is $0+Delay(ep_1)=4$. If $\rho=[(ep_1,0),(ep_2,4),(ep_3,7),(ep_1,17)]$, the length of $\rho$ can be calculated by
\[\iota(\rho)=Delay(ep_1)+Delay(ep_2)+Delay(ep_3)=17.\]

\section{Definition and notation}\label{concept}
In this section, we will discuss how to verify whether a task could always satisfies its time property. We start by introducing some concepts as preparations, then those concepts are integrated into a complete analysis method.

\subsection{Computational Requirement}
The main idea of our analysis method is to check whether the time interval between the task's activation and deadline is big enough to accommodate the execution time of itself and other tasks which could interrupt it. But how to delineate the execution of those tasks?

For example, if we are testing an instance of task $(e(t),d(t),l(t),r(t))$, in consideration of the features of schedule policy, this instance could not be affected by tasks with a lower priority than $l(t)$, or tasks have priority $l(t)$ and a larger activate time. Based on this fact, we introduce the concept of computational requirement to accumulate the execution time of tasks in an expiry point and dismiss the tasks which could not affect this instance.
\begin{definition}
For an instance of expiry point $(ep,r)$, we use computational requirement $\omega_{l(t),r(t)}(ep)$ to accumulate the execution time of tasks in $Act(ep)$, except those tasks which have a lower priority than $l(t)$ if $r\leq r(t)$. When $r>r(t))$, we also except tasks which have priority $l(t)$:
\begin{equation}
\omega_{l(t),r(t)}((ep,r))=\sum\limits_{task\in \xi_{l(t),r(t)}(ep)}e(task),
\end{equation}\label{equation_loweromega}
where 
\[
\xi_{l(t),r(t)}((ep,r))=\begin{cases}\{t'|t'\in Act(ep)\wedge l(t')\leq l(t)\}\qquad if\ r\leq r(t)\\
\{t'|t'\in Act(ep)\wedge l(t')<l(t)\}\qquad if\ r>r(t)
\end{cases}\]
\end{definition}
After proposing the computational requirement function, the total execution time during a path can be computed. We still use the name $computational\ requirement$ to denote this function, but a different way to calculate.
\begin{definition}
For a path $\rho=[(ep_1,r_1),(ep_2,r_2),\dots,(ep_n,r_n)]$, we use computational requirement $\Omega_{l,r}(\rho)$ to calculate how long those expiry points on this path will take to execute and only consider the tasks which could affect an instance of task $(e,d,l,r)$:
\begin{equation}
\Omega_{l,r}(\rho)=\sum_{i=1}^n\omega_{l,r}(\rho_i).
\end{equation}\label{equation_higheromega}
\end{definition}

\subsection{Request Function}\label{section_prf}
Due to the speciality of schedule table mechanism, after an expiry point expires, other expiry points cannot expire during delay time. We could use the prefix request function \cite{DBLP:journals/rts/Stigge015a} $prf^{ep}_{l,r}(\theta)$ to abstract the relation between length and computational requirement of paths.
\begin{definition}
For an expiry point $ep$, let prefix request function $prf^{ep}_{l,r}(\theta)$ denotes the maximal computational requirement $\Omega_{l,r}(\rho)$ among those paths $\rho$ which start by $(ep,0)$ and $\iota(\rho)<\theta$.
\begin{equation}
prf^{ep}_{l,r}(\theta)=max\{\Omega_{l,r}(\rho)|\rho \ start\ in\ (ep,0)\ \wedge\ length(\rho)<\theta\}.
\end{equation}\label{equation_prf}
\end{definition}

Beacuse no path has a length which is less than 0, we consider the prefix request function is meaningless when $\theta=0$.

%Regarding expiry point $ep$ in Figure \ref{illustration} as the superscript of prefix request function, we will get the result as the computational requirement of part B, the part C could be seek in a similar way. In a time interval, $ep$ is the start expiry point, $l$ is a priority level, and $r$ is release time. Only tasks with higher priority or not later release time, their execution time could be consider. Independent variable $\theta$ represent the length of time interval.

\begin{figure}[t]
  \centering
  \includegraphics[scale=0.32]{graphics/figure_prf.eps}
  \caption{An example for prefix request function of $prf^{ep_1}_{4,0}(\theta)$ according to $dst_1$ in Figure \ref{figure_dst1}.} 
  \label{figure_prf}
\end{figure}

Figure \ref{figure_prf} shows an example of prefix request function $prf^{ep_1}_{4,0}(\theta)$ (cf. Section \ref{section_dst_1}). 

When $0<\theta\leq4$, the path must be $[(ep_1,0)]$, which have computational requirement $\Omega_{4,0}([(ep_1,0)])=2$. When $4<\theta\leq7$, the path $[(ep_1,0),(ep_2,4)]$ makes the maximum computational requirement $\Omega_{4,0}([(ep_1,0),(ep_2,4)])=4$. when $7<\theta\leq17$, the path $\rho$ can be $[(ep_1,r0)]$, $[(ep_1,r0),(ep_2,4)]$ or $[(ep_1,0),(ep_2,4),(ep_3,7)]$. But in $ep_3$, the priority of $t_3$ is lower than 4, so the prefix request function wouldn't accumulate it, i.e., $\Omega_{4,0}([(ep_1,0),(ep_2,4)])=\Omega_{4,0}([(ep_1,0),(ep_2,4),(ep_3,7)])=4$. The function will keep returning 4 until $\theta$ exceeds 17.

A DST has as many prefix request functions as expiry points in this DST, so we use the maximal request function to integrate those prefix request functions.
\begin{figure}
  \centering
  \begin{subfigure}[t]{3.25in}
    \centering
    \includegraphics[scale=.45]{graphics/figure_dst2.eps}
    \caption{An example of $dst_2$ which contains two expiry points and $t_4=<1,3,3>,\ t_5=<3,8,5>$.}\label{figure_dst2}
  \end{subfigure}
  \quad
  \begin{subfigure}[t]{3.25in}
    \centering
    \includegraphics[scale=.325]{graphics/figure_mrf.eps}
    \caption{Maximal request funciton of $dst_2$ for $l=5$.}\label{figure_mrf}
  \end{subfigure}
  \caption{The $dst_2$ contains two expiry points, so there are two prefix request functions $prf^{ep_4}_{5+1,-1}$ and $prf^{ep_5}_{5+1,-1}$ in Figure \ref{figure_mrf}. When $0<\theta\leq2$, $prf^{ep_5}_{5+1,-1}$ makes more computational requirement. But in time interval (2,10], $prf^{ep_4}_{5+1,-1}$ provides the value of the maximal request function.}\label{figure_dst2_mrf}
\end{figure}
\begin{definition}
For a DST, the maximal request function $mrf^{dst}_l(\theta)$ calculates the maximum execution time caused by a time interval.% prefix request function among expiry points in a DST.
\begin{equation}
mrf^{dst}_l(\theta)=max\{prf^{ep}_{l+1,-1}(\theta)|ep\in Node\}
\end{equation}\label{equation_mrf}
\end{definition}

An example of a maximal request function is given in Figure \ref{figure_dst2_mrf}, where we provide another DST $dst2$ and illustrate the maximal request function of $dst_2$.

Besides considering paths which start with a specific expiry point, we also calculate the computational requirement of paths which end up in a specific expiry point $ep$ by the suffix request function \cite{DBLP:journals/rts/Stigge015a}. A slightly different between $srf$ and $prf$ is that the former ignores the expire time.% because all tasks considered in the suffix request function are activated earlier than tasks in $ep$.

\begin{definition}
For an expiry point $ep$, we use a suffix request function $srf^{ep}_{l}(\theta)$ to calaulate the maximal computational requirement $\Omega_{l+1,-1}(\rho)$ among those paths ending up in $(ep,r)$ but whose length not exceeds $\theta$.
\begin{equation}
srf^{ep}_l(\theta)=max\{\Omega_{l+1,-1}(\rho)|\rho\ end\ in\ (ep,r)\ \wedge\ length(\rho)\leq \theta\}.
\end{equation}\label{equation_srf}
\end{definition}
\begin{figure}[t]
  \centering
  \includegraphics[scale=0.31]{graphics/figure_srf.eps}
  \caption{Suffix request function of $srf^{ep_3}_{4}(\theta)$ according to $DST_1$ in Figure \ref{figure_dst1}.} 
  \label{figure_srf}
\end{figure}

In particular, we use $\Omega_{l+1,-1}(\rho)$ to accumulate the execution time of tasks which have priority not lower than $l$, regardless the activate time. We use Figure \ref{figure_srf} to illustrate the suffix request function $srf^{ep_3}_{4}(\theta)$.

%Figure \ref{figure_srf} illustrates the suffix request function $srf^{ep_3}_{4}(\theta)$. When $\theta$ start from 0, we calculate the computational requirement of path $[(ep_3,r_3)]$ and get $2$ as the result of the suffix request function; as $\theta$ reaches 3, path $[(ep_3,r_3)]$ and $[(ep_2,r_2),(ep_3,r_3)]$ meet the requirement and we choose the maximum value of computational requirement as 4. The rest may be deduced by analogy.

%Suffix request function describes the execution time of all tasks may block task $t$ in schedule table $st$ directly or indirectly, i.e., tasks which release earlier than task $t$, and have higher priority. before and not later than the task need to be verified.Note that the relationship between result of prefix request function and corresponding time $t$ reveal the computational requirement in time interval which length is $t$. 

\subsection{Busy Window}\label{section_busywindow}

A RTOS (Real-Time Operating System) strictly requires that the finish times of tasks are not allowed to exceed deadline. But in real life, identifying the task which causing time fault actually may be far from obvious. Imagine a task which takes too long to execute, but it does not violate its deadline. The task may block the execution of following tasks. Then the influence will spread throughout the running of tasks, which could makes a normal task misses its deadline. But in a execution of a DST, how to recognize those tasks which could cause or spread influences? 
In order to find a solution to this problem, we introduce the well-known concept named busy window \cite{DBLP:conf/rtss/Lehoczky90}. 

Busy window for priority level $l$ is a time interval that processor continuously executes tasks with priority $l$ or a higher priority. If we find the maximal busy window for $l$, then we could delimit how long a task could spread influence, i.e., an instance of task with priority $l$ can only be affected by tasks within this boundary. We denote the upper bound of busy window for $l$ by $\sigma_l$. %In order to calculate the upper bound of busy windows, we introduce the concept of the maximal request function.

\begin{lemma}
For a DST set $\tau$, we can get the upper bound of busy windows for $l$ by finding the minimum positive number $\theta$ which could satisfy
\begin{equation}
\sum\limits_{dst\in \tau}mrf^{dst}_l(\theta)=\theta.\label{equation_busywindow}
\end{equation}
\end{lemma}\label{lemma_busywindow}
\begin{proof}
Firstly, we state a fact that at the point of a busy window start, at least one expiry point expire in that point. So the computation of the upper bound of busy windows is all about finding those expiry points.

If there is a $\theta$ which satisfies Equation \ref{equation_busywindow}, we can find those paths which offer the maximal request functions at $\theta$ from DSTs. Then a set of expiry points is obtained by combining the first expiry points in those paths. When those expiry points expire at the same time, we can get the upper bound of busy windows for $l$.

Now assuming we use this method to get an expiry point $ep'$ in dst'. But there is another expiry point $ep''$ in $dst'$ which could make a longer busy window. Because the path start with $(ep'',0)$ does not offer the value of $mrf^{dst'}_l$ at $\theta$, i.e.,
\[prf^{ep''}_{l+1,-1}(\theta)<prf^{ep'}_{l+1,-1}(\theta).\]
When we choose $ep''$ instead of $ep'$ to expire with other expiry points simultaneously, the sum of the prefix request function is less than $\theta$, i.e., 

\begin{equation}
prf^{ep''}_{l+1,-1}(\theta)+E<prf^{ep'}_{l+1,-1}(\theta)+E=\theta, 
\end{equation}
where $E=\sum\limits_{dst\in \tau-d1}mrf^{dst}_l(\theta)$.

So the busy window starting with $ep''$ is shorter than $\theta$, leading to a contradiction.
\end{proof}

In some non-schedulable cases, the upper bound of busy windows is infinitely great. In order to recognize this situations, we introduce the definition of the hyperperiod of schedule tables as follow.
\begin{definition}
For a set of DSTs $\tau=\{dst_1,dst_2,\dots,dst_n\}$, we assume durations of them as $\delta_1,\delta_2,\dots,\delta_n$ respectively. The hyperperiod is the least common multiple of all duration of all schedule tables $lcm(\delta_1,\delta_2,\dots,\delta_n)$.
\end{definition}

\begin{lemma}
  A finite set of schedule tables is non-schedulable if there is a busy window exceeds hyperperiod of those schedule tables.
\end{lemma}\label{lemma_hyperperiod}
\begin{proof}
  The scheduling process of a set of repeating schedule tables is cyclic. If any busy window exceeds the hyperperiod, the processor will continuously execute tasks in this hyperperiod. In the next hyperperiod, except tasks which is activated in this hyperperiod, the processor also has to execute those tasks which are activated during the previous hyperperiod. So the tasks with the lowest priority must be blocked. By parity of reasoning, the task with the lowest priority must violate its deadline at some point.
\end{proof}
\subsection{Combination of Expiry Points}\label{section_combination}
In order to achieve completeness in schedulability analysis, our method needs to completely cover every schedule situations, including all offsets between schedule tables. Assuming there is a set of DST $\tau=\{dst_1,dst_2,\dots,dst_n\}$, the amount of offsets between those schedule tables equals to $\delta(dst_1)\times\delta(dst_2)\times\dots\times\delta(dst_n)$. The various offsets may lead to state explosion, so we try to mitigation this problem by using an expiry point to represent a series of offsets.

Expiry points shift as the DST changes its offset and now we temporarily restrict the range of shifting into a time interval. Because our schedulability analysis method always focuses on the computational requirement, so, if the computational requirement which is caused by a specific time interval is not less than those which are caused by a set of other time intervals, then we say this time interval dominates the others, cf. Figure \ref{figure_combination}.

\begin{figure}  
  \centering
  \begin{subfigure}[t]{3.33in}
    \centering
    \includegraphics[scale=.34]{graphics/figure_combina2.eps}
    \caption{$ep_3$ expires at 3, the computational requirement which is caused by this time interval is $\omega_{l,r}((ep_3,3)).$}\label{figure_combination1}
  \end{subfigure}
  \quad
  \begin{subfigure}[t]{3.33in}
    \centering
    \includegraphics[scale=.34]{graphics/figure_combina1.eps}
    \caption{$ep_3$ expires at 0, $ep_1$ expires at 10. This time interval makes the computational requirement as $\omega_{l,r}((ep_3,0))+\omega_{l,r}((ep_1,10))$.}\label{figure_combination2}
  \end{subfigure}
  \caption{In a time interval with length 10, the computational requirement which is caused by scenario (b) is larger than it which is caused by scenario (a), i.e., the time interval in scenario (b) dominates it in scenario (a).}\label{figure_combination}
\end{figure}
As Figure \ref{figure_combination}, when $ep_3$ expires at the begin, this time interval always dominates others that make $ep_3$ the first appearance. Regardless of the length of time interval, we can use $ep_3$ to denote this time interval, then represents the set of time interval which imply a series of offsets. So we replace offsets of a DST by its expiry points and replace $\delta(dst_1)\times\delta(dst_2)\times\dots\times\delta(dst_n)$ by combinations of expiry points.
\begin{definition}
For a set of DSTs $\tau=\{DST_1,DST_2,\dots,DST_n\}$, we use $\Phi$ to represent all combinations of expiry points of $\tau$.
\begin{equation}
  \Phi(\tau)=Node_1 \times Node_2\times\dots\times Node_n.
\end{equation}\label{equation_combination}
\end{definition}

We pick one expiry point from each DST to form a set which is denoted by $\varepsilon$, then $\varepsilon\in\Phi$.
\subsection{Schedulability Analysis of Tasks}
As mentioned above, we analyze the schedulability by checking whether the time interval between activation and deadline of a task is big enough to accommodate the execution time of itself and other tasks which could interrupt it. But according to Section \ref{section_busywindow}, except the time interval after activation, we also need to consider the time interval before activation. Therefore, we make the time interval grow further to the left. This brings another question, "how far should we extend the time interval?" This answer has been given in Section \ref{section_busywindow}, i.e., the length we extended should be less than the boundary of busy windows. Figure \ref{figure_3parts} shows the original time intervals with length $y$ and the extended time intervals with length $x+y$.
\begin{figure}
  \centering
  \includegraphics[scale=0.3]{graphics/figure_3parts.eps}
  \caption{An illustration of schedulability analysis of task $t$ which is activated by expiry point $ep$. There are three parts may affect the execution of $t$: A) interruption from $dst$ before task $t$ is activated, B) interruption from $dst$ after task $t$ is activated, C) interruption from other DSTs.}
  \label{figure_3parts}
\end{figure}

When several DSTs work concurrently, the influence on the execution of a specific task come from three parts: 1) tasks which are activated before the specific task from the same DST, 2) tasks which are activated after the specific task from the same DST, 3) tasks which from other DSTs, cf. Figure \ref{figure_3parts}. Note that the three parts are subject to change as DSTs shift their offsets or we change $x$ and $y$.

After sorting out these three parts, we check whether the extended time interval could accommodate them. 


%We calculate the three parts and accumulate them, then compare with the length of time interval ($x+y$). If this time interval could accommodate this three parts, the task will finish in this time interval. But the execution time of those three parts changes in different situations. So we need to travel all situations, including all offsets and all $x$. We travel all offsets and $x\leq\sigma_l$, since tasks which are activated $x$ ticks earlier would not cause effect (cf. Section \ref{section_busywindow}). Traveling all $y$ is not necessary, since as long as one $y\leq d(t)$ exists, a task could finish in time in this scene of offset and $x$.


\begin{theorem}
  For a finite set of DSTs $\tau$, if there is a $dst\in\tau$, expiry point $ep\in Node$, task $t\in Act(ep)$. Then task $t$ always meets its deadline if:
   \begin{equation}\begin{split}
      \forall \varepsilon\in\Phi(\tau-\{dst\}&),x\in[0,\sigma_l]:\exists y\in[e(lt),d(lt)]:\\
      srf^{ep}_{l(t)}(x)+&prf^{ep}_{l(t),-1}(y)-\omega_{l(t),-1}(ep)\\
      +&\sum\limits_{ep_i\in \varepsilon}prf^{ep_i}_{l(t),x}(x+y)\leq x+y,
    \end{split}\label{theorem_verification}\end{equation}
    where $\omega_{l(t),-1}(ep)$ is the overlap between $srf^{ep}_{l(t)}$ and $prf^{ep}_{l(t),-1}$ and we use the $dst$ as the controlled DST but change the offsets of other DSTs.
\end{theorem}
\begin{proof}

  Assuming Equation \ref{theorem_verification} evaluates to false, but task $t$ always meets its deadline. Since Equation \ref{theorem_verification} is false, there must exists a $\varepsilon\in\Phi(\tau-\{dst\})$ and a $x\leq \sigma_l$ makes the value of Equation \ref{equation_proof} is larger than $x+y$, where $y=0,1,2,\dots,d(t)$.
  \begin{equation}\begin{split}
      &\underbrace{srf^{ep}_{l(t)}(x)}_{part A}+\underbrace{prf^{ep}_{l(t),-1}(y)}_{part B}-\underbrace{\zeta^{(ep)}_{l(t),-1}}_{overlap}+\underbrace{\sum\limits_{ep_i\in \varepsilon}prf^{ep_i}_{l(t),x}(x+y)}_{part C},
    \end{split}\label{equation_proof}\end{equation}
  
  Equation \ref{equation_proof} accumulates the execution time of task $t$ and all tasks could affect it, i.e., $t$ is the last task to be finished among them. Therefore, the minimal $y$ makes Equation \ref{equation_proof} not larger than $x+y$ is the worst-case responds time. But due to inexistence of $y\leq d(t)$ could satisfy Equation \ref{theorem_verification}, so the WCRT exceed deadline. When expiry points in $\varepsilon$ expire $x$ ticks before the activation of $t$ contemporary, we find a situation that task $t$ could not meet its deadline, leading to a contradiction. 
  
  Now assuming Equation \ref{theorem_verification} holds, but task $t$ may violates its deadline. If an instance of $t$ misses its deadline, there must exist a group of instances of tasks which could interrupt the execution of instance of $t$. We assume that the smallest activate time in this group is $x$ ticks smaller than activate time of the instance of $t$. According to Lemma \ref{lemma_busywindow}, $x\leq \sigma_l$. Since the Equation \ref{theorem_verification} hold, the execution time caused by this group is less than or equal to $x+y$. So the task $t$ must be finished within $y$ ticks, which leading to a contradiction.
\end{proof}

%We illustrate this method as picking a task with lowest priority in this set of schedule tables, and verify whether this task could always meet its deadline, if the tasks pass verification, then pick another one. If all task pass verification, this set is declared as schedulable, if not, declared as non-schedulable.Verification of task is the foremost step in our method, so we give an overview of it: For a schedule table $st$ cotains expiry point $ep$, and $ep$ could activate task $t$, $t$ could always meets its deadline if other tasks always caues less than $d(t)-e(t)$ ticks interference in $d(t)$ ticks after releasing $t$.

\section{Schedulability analysis method}
In this part, we synthesizing those definitions given above into an integrated method to deal with the schedulability analysis problem.
%\subsection{Preprocessing}

\subsection{Stages of Method}\label{section_8steps}
The process of our integrated method can be divided into several stages as follows:
\begin{compactdesc}
  \item[Get hyperperiod]: We calculate the hyperperiod of the set of DSTs $\tau=\{dst_1,dst_2, \dots dst_n\}$.

  \item[Find a task with the lowest priority]: Picking one task with the lowest priority among $Task_1\cup Task_2\cup\dots\cup Task_n$ and denoting it as $lt$. 
  \item[Divide the set of DSTs]: dividing $\tau$ into two parts: i) the DST could activate $lt$, ii) the set of the other DSTs. Denoting the two parts by $ldst$ and $other\_dsts$ respectively. The next four steps are aimed to verify whether $lt$ could always meet its deadline. 

  \item[Calculate boundary of busy window]: Calculating the upper bound of busy windows for $l(lt)$ and denoting that by $\sigma_l$. If $\sigma_l$ exceed the value of hyperperiod, the set of DSTs is non-schedulable.
  
  %Whenever determine one combination of start expiry point, need to set the release time of tasks those schedule table in $other\_st$ could activate, i.e., all tasks activate by start expiry point, set their release time to 0, release time of the rest of tasks are set according to the offset to start expiry point.
  \item[Set instances of tasks]: After picking one $\varepsilon\in\Phi(other\_dsts)$, we structure a path for each DST: expiry points in $\varepsilon$ expire $x$ ticks before releasing task $lt$ at the same time, cf. Figure \ref{figure_3parts}. We set expire time of those expiry points as 0. The rest of paths are structured according to delays of expiry points. Then we set the activate times of instances of tasks according to those paths.

  \item[Verify schedulability in single combination]: Verifying whether the equation below could be satisfied, where we assume $lep$ is the expiry point which could activate $lt$:
  \begin{equation}\begin{split}
      &\forall x\in[0,\sigma_l]:\exists y\in[e(lt),d(lt)]:\\
      srf^{lep}_{l(lt)}(x)+&prf^{lep}_{l(lt),-1}(y)-\zeta^{(lep)}_{l(lt),-1}+\sum\limits_{ep_i\in\varepsilon}prf^{ep_i}_{l(lt),x}(x+y)\leq x+y
    \end{split}\label{equation_verify}\end{equation}
  
  \item[Verify schedulability in all combination]: If Equation \ref{equation_verify} is satisfied, then we pick other $\varepsilon\in\Phi(other\_st)$ and repeat from setting instances of tasks. Until all $\varepsilon$ have been picked, then we move to the next step. Instead, if there exist a situation couldn't satisfy Equation \ref{equation_verify}, we declare this set of DSTs is non-schedulable, and find a counter example.
  \item[Switch to another task]: Picking one task with the lowest priority in this set except tasks already passed verification and repeating the procedure from dividing the set of DSTs.
  \item[Declared schedulable]: After all task in this set of DSTs passed validation, this set is declared as schedulable. 
\end{compactdesc}

\subsection{Integrated Method}
We summarize those steps and give two primary algorithms as below. In those two algorithms, $\tau$ is a global variable which represents the set of DSTs. $task\_set$ is also a global variable which represents the set of all tasks in $\tau$.

\begin{algorithm}
  \caption{SCHEDULABILITY}
  \label{algorithm_schedulability}
  \begin{algorithmic}[1]
    \REQUIRE 
    \ENSURE schedulable or non-schedulable 
    \IF{$task\_set=\varnothing$}
    \STATE \Return schedulable
    \ELSE \STATE $lt \leftarrow GET\_LOWEST\_PRIORITY(task\_set)$\\$\qquad\qquad\qquad\backslash\backslash task\_set\ is\ a\ global\ variable$
    \IF{$pass=TASK\_SCHEDULABILITY\_ANALYSIS(lt)$}
    \STATE $task\_set\leftarrow task\_set-lt$
    \STATE \Return SCHEDULABILITY()
    \ELSE
    \STATE \Return non-schedulable 
    \ENDIF
    \ENDIF
  \end{algorithmic}
\end{algorithm}

At the begin of Algorithm \ref{algorithm_schedulability}, we implement line 1 and 2 to check whether the algorithm should terminate. Line 4 is corresponding to the second step in section \ref{section_8steps} which gets the task with the lowest priority. We conceal the implementation details of the function $GET\_LOWEST\_PRIORITY$. 

After getting the target task $lt$, the function $TASK\_VERIFY$ in line 5 is the implementation of Theorem \ref{theorem_verification}. According to this theorem, if the function returns $pass$, then the task will always meet its deadline. We will remove $lt$ from the task set $task\_set$ in line 6 and continue process the algorithm $SCHEDULABILITY$. So whenever the set $task\_set$ is empty, all tasks have been confirmed to always meet its deadline. Therefore the set of DSTs is schedulable. Instead, if the return result of $TASK\_VERIFY$ is $not-pass$, that means at least one counter example is detected and the set of DSTs is non-schedulable. We show the detail in Algorithm \ref{algorithm_taskverify}.


\begin{algorithm}
  \caption{TASK\_SCHEDULABILITY\_ANALYSIS}
  \label{algorithm_taskverify}
  \begin{algorithmic}[1]
    \REQUIRE $lt$
    \ENSURE pass or not-pass
    \IF{$\sigma_l\leftarrow BOUNDARY(l(lt))>hyperperiod$}
    \STATE \Return not-pass
    \ELSE
    \FOR{$\forall\quad\varepsilon \in \Phi(other\_dsts)$}
    \FOR{$\forall\quad\ x\in[0,\sigma_l]$}
    \FOR{$\forall y\in[e(lt),d(lt)]$}
    \IF {$SRF^{lep}_{l(lt)}(x)+PRF^{lep}_{l(lt),-1}(y)-\zeta^{lep}_{l(lt),-1}+$\\$\sum\limits_{ep_i\in\varepsilon}PRF^{ep_i}_{l(lt),x}(x+y)>x+y$}
    \STATE \Return not-pass
    \ENDIF
    \ENDFOR
    \ENDFOR
    \ENDFOR
    \STATE \Return pass
    \ENDIF
  \end{algorithmic}
\end{algorithm}

Algorithm \ref{algorithm_taskverify} aims to verify whether task $lt$ always meet its deadline. We use $lep$ to represent the expiry point which could activate $lt$. Line 1 and 2 compute the boundary of busy windows and compare with the hyperperiod. The function $BOUNDARY$ is an implementation of Lemma \ref{lemma_busywindow}. From line 4 to 7 we implement the Equation \ref{theorem_verification}, which could traverse all situations in scheduling $lt$. $SRF$ and $PRF$ represent the suffix request function and the prefix request function respectively. If the task $lt$ could not satisfy Equation \ref{theorem_verification}, the algorithm returns $not-pass$, else returns $pass$.

%Now, we analyze the computational complexity of our algorithms, firstly, we try to analyze Algorithm \ref{algorithm_taskverify} and assume an expiry point could activate up to $L$ tasks, a DST could contain at most $M$ expiry points, the maximal number of DSTs is $N$, the maximal number of hyperperiod is $H$.Then we start from the equation \ref{equation_loweromega}, this equation accumulates the execution time of all tasks in an expiry point, so we give $O(L)$ to it. The equation \ref{equation_higheromega} accumulate the the execution time over a path $\rho$, in view of expiry points can not share the same offset, we consider the number of expiry points equal to the lentgh of the path, so the complexity is $O(\iota(\rho))\times L$. The two request functions have the same complexity as $O(L\times \theta!)$, since $\theta$ decisions the lengths of paths. During the process of calculate upper bound of busy window, we determine the complexity is $O(M\times L\times H!\times N\times H)$, for we need to calculate $H$ times to obtain the boundary. For the line 4 to line 7, the three loops provide $O(M^{2N}\times H!\times L\times H^2)$, so we summarize the complexity of Algorithm as $O(M^{2N}\times H!\times L\times H^2)$. Due the complexity of Algorithm \ref{algorithm_schedulability} only provides a linear relationship to the number of tasks, the complexity is $O(M^{2N+1}\times H!\times L^2\times H^2 \times N)$.

\subsection{Demonstration}\label{section_demonstration}
We show an example for this method. In this set of DSTs, except the DST $dst_1$ in Figure \ref{figure_dst1} and $dst_2$ in Figure \ref{figure_dst2}, we add one more DST $dst_3$ in Figure \ref{figure_dst3} into this set.

\begin{figure}
  \centering
  \includegraphics[scale=.4]{graphics/figure_dst3.eps}
  \caption{An example of DST $dst_3$, where $t_6=<2,11,6>,\ t_7=<1,3,4>$.} 
  \label{figure_dst3}
\end{figure}

In this case, the set of DSTs $\tau =\{dst_1,dst_2,dst_3\}$. Hyperperiod is calculated as the least common multiple of the duration of three DSTs which equals to 2380 ticks. Then we get the set of tasks, denote as $task\_set$: 
\[\begin{split}
task\_set=Tasks_1\cup Tasks_2\cup Tasks_3=\{t_1,t_2,t_3,t_4,t_5,t_6,t_7\}.
\end{split}\]

Picking a task in $task\_set$ with the lowest priority, denoting as $lt$. For example we choose $t_3$. Task $t_3$ divides $\tau$ into two parts: $dst_1$ and $\{dst_2,dst_3\}$, which are denoted by $ldst$ and $other\_dsts$ respectively. 

After finding $lt$, we can get the upper bound of busy windows for $l(t_3)$ by Equation \ref{equation_busywindow} and denote it as $\sigma_l$ = 13. 

The next step, we use $\Phi(\tau)$ to get all combinations of expiry points as $\{\{ep_4,ep_6\},\{ep_5,ep_6\}\}$. Assuming we pick $\varepsilon=\{ep_4,ep_6\}$ firstly. Then we get the path $\rho_1=[(ep_4,0),(ep_5,3),(ep_4,14)\dots]$ for $dst_2$ and $\rho_2=[(ep_6,0),(ep_6,20),(ep_6,40),\dots]$. According to those paths, we set a series of instances of tasks like: $<1,3,3,0>$ and $<1,3,3,14>$ of $t_4$, $<2,11,6,20>$ of $t_6$, $<1,3,4,20>$ of $t_7$ and so on.


Then we verify whether there exists a $y\in(0,d(t_3)]$ for any $x\in[0,\sigma_l]$ could satisfy Equation \ref{equation_verify}, i.e.,
\[\begin{split}
&\forall x\in[0,13]:\exists y\in[2,9]:\\
srf^{ep_3}_6(x)+&prf^{ep_3}_{6,-1}(y)-\zeta^{ep_3}_{6,-1}+\sum\limits_{ep_i\in \varepsilon}prf^{ep_i}_{6,x}(x+y)\leq x+y.
\end{split}\]


When x = 0, there is y = 9 could satisfy the requirement, when x = 1, y =8 satisfy the requirement, ..., x = 13, y =3 satisfy the requirement. Then we verify other $\varepsilon\in\Phi(other\_dsts)$ until all elements in $\Phi(other\_dsts)$ pass validation.

After verifying schedulability in all combination, we delete $t_3$ from $task\_set$. Then we continue pick another task with the lowest priority in $task\_set$ and repeat those steps. Finally, the algorithm will stop when $task\_set$ is empty or a situation could not pass verification.


\section{Experimental analysis}
In order to validate the effectiveness of our method, we setup an experiment to compare the result of our method and the execution on the real implemented AUTOSAR OS. In this experiment, we develop a program to generate schedule tables randomly, then implement them on a real-life AUTOSAR while analyzing them by our algorithm. Finally, we compare results to prove the correctness of our method.
\subsection{Experiment Setup}
We generate a set of schedule tables in seven parameters which are shown as below: 

\begin{compactitem}
  \item $st_{num}$, the number of schedule tables.
  \item $ep_{num}$, the maximal number of expiry points that a schedul table could contain.
  \item $task_{num}$, the maximal number of tasks that an expiry point could activate.
  \item $Delay$, the delay of an expiry point.
  \item $e(t)$, the execution time of a task.
  \item $d(t)$, the deadline of a task.
  \item $\delta$, the duration of schedule tables.
  %
\end{compactitem}
And the Table \ref{range} gives the ranges of parameters:
\begin{table}[htbp]
  \centering
  \begin{tabular}{llllll}
    \toprule
    $st_{num}$ & $ep_{num}$ & $task_{num}$ & $Delay$ & $e(t)/d(t)$ & $d(t)/\delta$\\
    \midrule
    $[2,6]$&$[1,4]$&$[1,3]$&$[10,30]$&$[0,0.16]$&$[0.1,0.5]$\\
    \bottomrule
  \end{tabular}
  \caption{Ranges of parameters to generate set of schedule tables}\label{range}
\end{table}
%Except that, another goal of this generator is generating tasks randomly, we decide introduce slackness ratio $\eta$ to achieve that. We firstly define slackness on a task $t$ as $d(t)-e(t)$, 

After generating schedule tables randomly, on the one hand, we transform those schedule tables into DSTs and input them into our method. Then get the result of schedulability. On the other hand, we deploy those schedule tables into an implemented AUTOSAR by a configuration tool and debug the operating system to test the schedulability. 

In this experiment, we use an industrial-used AUTOSAR operating system which is developed by iSoft Infrastructure Software Co., Ltd. Our target hardware platform is TC1782 32-Bit Single-Chip Microcontroller and more information about TC1782 in \cite{infineon.org}. 

This industrial-used AUTOSAR OS also provides a matched configuration tool to generate the configuration file and an user interface. We use this tool to generate configuration files follow up with our request and deploy our generated schedule tables into AUTOSAR by modifying the user interface. In order to implement deadline detection, we also setup an alarm for each task, which will expire when task's on deadline. The alarm is assigned to a callback routine which could check the state of the corresponding task. If the state is not suspended, i.e., this task is not finished yet, the callback routine will return false. If the state is suspended, the callback routine will return true. With those alarms, we could find the task which violates deadline as soon as time faults raises. 
%Except those alarms, in order to simulate the transitions between three states of schedule table by calling APIs

\subsection{Consistency Analysis} 
%We introduce a new feature utilization $\eta$ to assist our comparison. For a schedule table $st$ 
%\[\eta=\frac{\sum\limits_{ep_i\in Node(st)}\sum\limits_{t_i\in Act(ep_i)}e(t_i)}{\delta}\] 
%i.e., ratio of sum of all tasks' execution time in st to duraiton of st.
The experiment of comparison shows that the result of our method all compared exactly to an actual running situation on the implemented AUTOSAR. Several examples and their result are synthesized in Table \ref{table_compare}, we use $task_{sum}$ represent the number of tasks in each example. %($\sum\eta$ represent the sum of utilization of all schedule tables, it's obviously not schedulable when this value exceed 100).


\begin{table}[htbp]
  \centering
  \begin{tabular}{llllll}
    \toprule
    &&\multicolumn{2}{c}{Schedulability}\\
    \cmidrule{3-4}
    $st_{num}$ & $task_{sum}$ & our method & industrial OS\\
    \midrule
    3&14&Invalid&Invalid\\
    4&28&  Valid&    Valid\\
    5&36&Invalid&Invalid\\
    6&27&Invalid&Invalid\\
    %9&33&TIME OUT&NOT valid\\10&100&TIME OUT&NOT valid\\
    
    \bottomrule
  \end{tabular}
  \caption{Comparison of schedulability analysis result}
  \label{table_compare}
\end{table}

If the schedulability result obtained by our method is non-schedulable, an amending advice is given. Such as the example given in Section \ref{section_demonstration}, when we test task $t_7$, Equation \ref{theorem_verification} could not be satisfied when $x=0$ at the scenario $\varepsilon={ep_4,ep_6}$. Then we try to widen it's deadline from 3 ticks to 4 ticks and test $t_7$ repeatedly. Until it pass validation, cf. Figure \ref{figure_widen}. Then we modify any tasks could not pass validation. Finally, we get an amended example, which is schedulable and it is schedulable on implemented AUTOSAR as well.

\begin{figure}
  \centering
  \includegraphics[scale=.45]{graphics/figure_widen.eps}
  \caption{$t_7$ is activated by $ep_6$ at 0. But $t_7$ could not be finished until 4, which makes $t_7$ violates it's deadline.}
  \label{figure_widen}
\end{figure}

\section{Conclusion}
In this paper, we have abstracted the behaviors of schedule tables as formal models and proposed an algorithm based on the models. Our algorithm is to analyze the schedulability of AUTOSAR OS by travelling all the possible offsets between schedule tables. Moreover, we conduct an experiment, which runs a set of testbench on an industrial AUTOSAR OS and the experiment respectively to check the effectiveness of our method. Through the comparison result, we believe that our method could perform well in assisting developers in designing schedule tables.
 
This work has gotten a promising result in analyzing AUTOSAR OS on uniprocessor. Since AUTOSAR specification has introduced multicore operating systems, we are considering to work on schedulability analysis of them. Besides, schedulability analysis for extended tasks, which are allowed to synchronize through setting and waiting events, is another interesting topic we would like to pursue.


\bibliographystyle{ACM-Reference-Format}
\bibliography{sample-bibliography}

\end{document}
